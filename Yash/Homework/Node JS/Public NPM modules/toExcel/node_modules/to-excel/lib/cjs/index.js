"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toExcel = void 0;
const constants_1 = require("./constants");
/**
 * project: to-excel
 * author: m0rtadelo (ricard.figuls)
 * @license MIT
 * 2019
 */
class toExcel {
    /**
     * Generates compatible Excel xls file (xml in fact) and returns content and downloads (if set)
     * @param columns This object defines column labels and maps worksheet data.
     * @param data  Sets the data of the worksheet.
     * @param options Options to define behaviour
     * @returns content of file
     */
    static exportXLS(columns, data, options) {
        options = options || { filename: undefined };
        if (typeof options === 'string') {
            options = { filename: options };
        }
        options.extension = options.extension || constants_1.DEFAULT_EXT;
        const xml = toExcel.generateXML(columns, data, options);
        if (options.download !== false) {
            toExcel.download(options.filename + '.' + options.extension, xml);
        }
        return xml;
    }
    /**
     * Generates compatible Excel xls file (xml in fact)
     * @param columns This object defines column labels and maps worksheet data.
     * @param data Sets the data of the worksheet.
     * @param options Options to define behaviour
     * @returns content of file
     */
    static generateXML(columns, data, options) {
        let xml = '';
        if (columns.length && data) {
            xml = constants_1.X_HEADER;
            xml += constants_1.X_PROPS
                .replace('%author', toExcel.parseXML(options.author || constants_1.DEFAULT_AUTHOR))
                .replace('%lastAuthor', toExcel.parseXML(options.lastAuthor || constants_1.DEFAULT_AUTHOR))
                .replace('%company', toExcel.parseXML(options.company || constants_1.DEFAULT_COMPANY))
                .replace('%version', toExcel.parseXML(options.version || constants_1.DEFAULT_VERSION));
            xml += constants_1.X_STYLES;
            xml += '<Worksheet ss:Name="' + options.filename + '"><Table>';
            xml += constants_1.X_ROW_START;
            xml += toExcel.addHeaders(columns);
            xml += constants_1.X_ROW_END;
            xml += toExcel.addRows(data, columns);
            xml += constants_1.X_FOOTER;
        }
        return xml;
    }
    /**
     * Returns the XML headers for the columns
     * @param columns The headers info array
     * @returns XML headers
     */
    static addHeaders(columns) {
        let xml = '';
        for (const column of columns) {
            xml += constants_1.X_CELL_START +
                toExcel.parseXML(column.label) +
                constants_1.X_CELL_END;
        }
        return xml;
    }
    /**
     * Returns XML rows
     * @param data The cells data
     * @param columns The columns data
     * @returns XML rows
     */
    static addRows(data, columns) {
        let xml = '';
        for (const item of data) {
            xml += '\n<Row>';
            for (const column of columns) {
                const t = column.type ? column.type : 'String';
                const r = toExcel.parseXML(toExcel.getData(item, column.field));
                xml +=
                    '<Cell><Data ss:Type="' + t + '">' +
                        (t === 'Number' ? +r : r) +
                        '</Data></Cell>';
            }
            xml += constants_1.X_ROW_END;
        }
        return xml;
    }
    /**
     * Uses browser integrated method to download the generated file
     * @param filename The filename
     * @param data The data to be in the file
     * @returns void
     */
    static download(filename, data) {
        try {
            const blob = new Blob([data], { type: 'text/csv' });
            if (window.navigator.msSaveOrOpenBlob) {
                window.navigator.msSaveBlob(blob, filename);
            }
            else {
                const elem = window.document.createElement('a');
                elem.href = window.URL.createObjectURL(blob);
                elem.download = filename;
                document.body.appendChild(elem);
                elem.click();
                document.body.removeChild(elem);
            }
        }
        catch (error) { }
    }
    /**
     * Returns the correct data value
     * @param row Data object that contains value
     * @param item The name of the item where data is
     * @returns The value
     */
    static getData(row, item) {
        let obj = row;
        try {
            item.toString().split('.').forEach(function (key) {
                obj = obj[key];
            });
        }
        catch (error) {
            obj = undefined;
        }
        return toExcel.replaceValue(obj);
    }
    /**
     * Replaces value
     * @param value value
     * @param replacementValue replacementValue
     * @returns void
     */
    static setReplace(value, replacementValue) {
        toExcel.replaceItems.push({ value, replacementValue });
    }
    /**
     * Sanitizes the string to be used in the XML value cell
     * @param input The input string to sanitize
     * @returns Sanitized xml string
     */
    static parseXML(input) {
        let output;
        if (input === undefined || input === null)
            return '';
        output = input.toString().split('&').join('&amp;');
        output = output.split('<').join('&lt;');
        output = output.split('>').join('&gt;');
        output = output.split('"').join('&quot;');
        return output;
    }
    /**
     * Replaces the value
     * @param value The vaue to be replaced
     * @returns The value or replaced value
     */
    static replaceValue(value) {
        for (const item of toExcel.replaceItems) {
            if (item.value === value) {
                return item.replacementValue;
            }
        }
        return value;
    }
}
exports.toExcel = toExcel;
toExcel.replaceItems = [];
